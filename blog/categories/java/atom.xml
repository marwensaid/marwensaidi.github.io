<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Tug's Blog]]></title>
  <link href="http://tgrall.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://tgrall.github.io/"/>
  <updated>2015-12-10T11:44:30+01:00</updated>
  <id>http://tgrall.github.io/</id>
  <author>
    <name><![CDATA[Tug Grall]]></name>
    <email><![CDATA[tugdual@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache Drill : How to Create a New Function?]]></title>
    <link href="http://tgrall.github.io/blog/2015/07/22/apache-drill-how-to-create-a-new-function/"/>
    <updated>2015-07-22T02:32:54+02:00</updated>
    <id>http://tgrall.github.io/blog/2015/07/22/apache-drill-how-to-create-a-new-function</id>
    <content type="html"><![CDATA[<p><a href="https://drill.apache.org/">Apache Drill</a> allows users to explore <em>any type of</em> data using ANSI SQL. This is great, but Drill goes even further than that and allows you to create custom functions to extend the query engine. These custom functions have all the performance of any of the Drill primitive operations, but allowing that performance makes writing these functions a little trickier than you might expect.</p>

<p>In this article, I&rsquo;ll explain step by step how to create and deploy a new function using a very basic example. Note that you can find lot of information about <a href="https://drill.apache.org/docs/develop-custom-functions-introduction/">Drill Custom Functions in the documentation</a>.</p>

<p>Let&rsquo;s create a new function that allows you to mask some characters in a string, and let&rsquo;s make it very simple. The new function will allow user to hide <em>x</em> number of characters from the start and replace then by any characters of their choice. This will look like:</p>

<pre><code>MASK( 'PASSWORD' , '#' , 4 ) =&gt; ####WORD
</code></pre>

<p>You can find the full project in the following <a href="https://github.com/tgrall/drill-simple-mask-function">Github Repository</a>.</p>

<p>As mentioned before, we could imagine many advanced features to this, but my goal is to focus on the steps to write a custom function, not
so much on what the function does.</p>

<!--more-->


<h2>Prerequisites</h2>

<p>For this you will need:</p>

<ul>
<li>Java Developer Kit 7 or later</li>
<li>Apache Drill 1.1 or later</li>
<li>Maven 3.0 or later</li>
</ul>


<h2>Dependencies</h2>

<p>The following Drill dependency should be added to your maven project</p>

<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;org.apache.drill.exec&lt;/groupId&gt;
      &lt;artifactId&gt;drill-java-exec&lt;/artifactId&gt;
      &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h2>Source</h2>

<p>The <code>Mask</code> function is an implementation of the <a href="https://github.com/apache/drill/blob/master/exec/java-exec/src/main/java/org/apache/drill/exec/expr/DrillSimpleFunc.java"><code>DrillSimpleFunc</code></a>.</p>

<p>Developers can create 2 types of custom functions:</p>

<ul>
<li>Simple Functions: these functions have a single row as input and produce a single value as output</li>
<li>Aggregation Functions: that will accept multiple rows as input and produce one value as output</li>
</ul>


<p>Simple functions are often referred to as UDF&rsquo;s which stands for user defined function.  Aggregation functions are referred to as UDAF which
stands for user defined aggregation function.</p>

<p>In this example, we just need to transform the value of a column on each row, so a simple function is enough.</p>

<h4>Create the function</h4>

<p>The first step is to implement the <a href="https://github.com/apache/drill/blob/master/exec/java-exec/src/main/java/org/apache/drill/exec/expr/DrillSimpleFunc.java"><code>DrillSimpleFunc</code></a> interface.</p>

<pre><code class="java">package org.apache.drill.contrib.function;

import org.apache.drill.exec.expr.DrillSimpleFunc;
import org.apache.drill.exec.expr.annotations.FunctionTemplate;

@FunctionTemplate(
        name="mask",
        scope= FunctionTemplate.FunctionScope.SIMPLE,
        nulls = FunctionTemplate.NullHandling.NULL_IF_NULL
)
public class SimpleMaskFunc implements DrillSimpleFunc{

    public void setup() {

    }

    public void eval() {

    }
}
</code></pre>

<p>The behavior of the function is driven by annotations (line 6-10)
  * <em>Name</em> of the function
  * <em>Scope</em> of the function, in our case Simple
  * What to do when the value is NULL, in this case Reverse will just returns NULL</p>

<p>Now we need to implement the logic of the function using <code>setup()</code> and <code>eval()</code> methods.</p>

<ul>
<li><code>setup</code> is self-explanatory, and in our case we do not need to setup anything.</li>
<li><code>eval</code> that is the core of the function. As you can see this method does not have any parameter, and return void. So how does it work?</li>
</ul>


<p>In fact the function will be generated dynamically (see <a href="https://github.com/apache/drill/blob/master/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillSimpleFuncHolder.java#L42">DrillSimpleFuncHolder</a>), and the input parameters and output holders are defined using holders by annotations. Let&rsquo;s look into this.</p>

<pre><code class="java">import io.netty.buffer.DrillBuf;
import org.apache.drill.exec.expr.DrillSimpleFunc;
import org.apache.drill.exec.expr.annotations.FunctionTemplate;
import org.apache.drill.exec.expr.annotations.Output;
import org.apache.drill.exec.expr.annotations.Param;
import org.apache.drill.exec.expr.holders.IntHolder;
import org.apache.drill.exec.expr.holders.NullableVarCharHolder;
import org.apache.drill.exec.expr.holders.VarCharHolder;

import javax.inject.Inject;


@FunctionTemplate(
        name = "mask",
        scope = FunctionTemplate.FunctionScope.SIMPLE,
        nulls = FunctionTemplate.NullHandling.NULL_IF_NULL
)
public class SimpleMaskFunc implements DrillSimpleFunc {

    @Param
    NullableVarCharHolder input;

    @Param(constant = true)
    VarCharHolder mask;

    @Param(constant = true)
    IntHolder toReplace;

    @Output
    VarCharHolder out;

    @Inject
    DrillBuf buffer;

    public void setup() {
    }

    public void eval() {

    }

}
</code></pre>

<p>We need to define the parameters of the function. In this case we have 3 parameters, each defined using the <code>@Param</code> annotation.  In addition, we also have to define the returned value using the <code>@Output</code> annotation.</p>

<p>The parameters of our mask function are:</p>

<ul>
<li>A nullable string</li>
<li>The mask char or string</li>
<li>The number of characters to replace starting from the first</li>
</ul>


<p>The function returns :</p>

<ul>
<li>A string</li>
</ul>


<p>For each of these parameters you have to use an holder class. For the <code>String</code>, this is managed by a <code>VarCharHolder</code> or <code>NullableVarCharHolder</code> -lines 21, 24,30- that provides a buffer to manage larger objects in a efficient way. Since we are manipulating a <code>VarChar</code> you also have to inject another buffer that will be used for the output -line 33-. Note that Drill doesn&rsquo;t actually use the Java heap for data being processed in a query but instead keeps this data off the heap and manages the life-cycle for us without using the Java
garbage collector.</p>

<p>We are almost done since we have the proper class, the input/output object, we just need to implement the <code>eval()</code> method itself, and use these objects.</p>

<pre><code class="java">public void eval() {

    // get the value and replace with
    String maskValue = org.apache.drill.exec.expr.fn.impl.StringFunctionHelpers.getStringFromVarCharHolder(mask);
    String stringValue = org.apache.drill.exec.expr.fn.impl.StringFunctionHelpers.toStringFromUTF8(input.start, input.end, input.buffer);

    int numberOfCharToReplace = Math.min(toReplace.value, stringValue.length());

    // build the mask substring
    String maskSubString = com.google.common.base.Strings.repeat(maskValue, numberOfCharToReplace);
    String outputValue = (new StringBuilder(maskSubString)).append(stringValue.substring(numberOfCharToReplace)).toString();

    // put the output value in the out buffer
    out.buffer = buffer;
    out.start = 0;
    out.end = outputValue.getBytes().length;
    buffer.setBytes(0, outputValue.getBytes());
}
</code></pre>

<p>The code is quite simple:</p>

<ul>
<li>Get the mask itself - line 4</li>
<li>Get the value - line 5</li>
<li>Get the number of character to replace - line 7</li>
<li>Generate a new string with masked values - lines 10/11</li>
<li>Create and populate the output buffer - lines 14 to 17</li>
</ul>


<p>This code does, however, look a bit strange to somebody used to reading Java code. This strangeness arises because the final code that is executed in a query will actually be generated on the fly. This allows Drill to leverage Java&rsquo;s just-in-time (JIT) compiler for maximum speed. To make this work, you have to respect some basic rules:</p>

<ul>
<li><strong>Do not use imports, but instead use the fully qualified class name</strong>, this is what is done on line 10 with the <code>Strings</code> class. (coming from the Google Guava API packaged in Apache Drill)</li>
<li>The <code>ValueHolders</code> classes, in our case <code>VarCharHolder</code> and <code>IntHolder</code> should be manipulated like structs, so you must call helper methods, for example <code>getStringFromVarCharHolder</code> and <code>toStringFromUTF8</code>. Calling methods like <code>toString</code> will result in very bad problems.</li>
</ul>


<p>Starting in Apache Drill 1.3.x, it is mandatory to specify the package name of your function in the <code>./resources/drill-module.conf</code> file as follow:</p>

<pre><code>drill {
  classpath.scanning {
    packages : ${?drill.classpath.scanning.packages} [
      org.apache.drill.contrib.function
    ]
  }
}
</code></pre>

<p>We are now ready to deploy and test this new function.</p>

<h3>Package</h3>

<p>Once again since, Drill will generate source, <em><strong>you must prepare your package in a way that classes and sources of the function are present in the classpath</strong></em>. This is different from the way that Java code is normally packaged but is necessary for Drill to be able to do the necessary code generation. Drill uses the compiled code to access the annotations and uses the source code to do code generation.</p>

<p>An easy way to do that is to use maven to build your project, and, in particular, use the <a href="https://maven.apache.org/plugins/maven-source-plugin/">maven-source-plugin</a> like this in your <code>pom.xml</code> file:</p>

<pre><code class="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;attach-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;jar-no-fork&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<p>Now, when you build using <code>mvn package</code>, Maven will generate 2 jars:</p>

<ul>
<li>The default jar with the classes and resources (<em>drill-simple-mask-1.0.jar</em>)</li>
<li>A second jar with the sources (<em>drill-simple-mask-1.0-sources.jar</em>)</li>
</ul>


<p>Finally you must add a <code>drill-module.conf</code> file in the resources folder of your project, to tell Drill that your jar contains a custom function. If you have no specific configuration to set for your function you can keep this file empty.</p>

<p>We are all set, you can now package and deploy the new function, just package and copy the Jars into the Drill 3rd party folder; $DRILL_HOME/jars/3rdparty , where $DRILL_HOME being your Drill installation folder.</p>

<pre><code>mvn clean package

cp target/*.jar  $DRILL_HOME/jars/3rdparty
</code></pre>

<p>Restart drill.</p>

<h3>Run !</h3>

<p>You should now be able to use your function in your queries:</p>

<pre><code>SELECT MASK(first_name, '*' , 3) FIRST , MASK(last_name, '#', 7) LAST  FROM cp.`employee.json` LIMIT 5;
+----------+------------+
|  FIRST   |    LAST    |
+----------+------------+
| ***ri    | ######     |
| ***rick  | #######    |
| ***hael  | ######     |
| ***a     | #######ez  |
| ***erta  | #######    |
+----------+------------+
</code></pre>

<h2>Conclusion</h2>

<p>In this simple project you have learned how to write, deploy and use a custom Apache Drill Function. You can now extend this to create your own function.</p>

<p>One important thing to remember when extending Apache Drill (using a custom function, storage plugin or format), is that Drill runtime is generating dynamically lot of code. This means you may have to use a very specific pattern when writing and deploying your extensions. With our basic function this meant we had to:</p>

<ul>
<li>deploy <strong>classes AND sources</strong></li>
<li>use <strong>fully Qualified Class Names</strong></li>
<li>use value holder classes and helper methods to manipulate parameters
*</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moving My Beers From Couchbase to MongoDB]]></title>
    <link href="http://tgrall.github.io/blog/2015/02/01/moving-my-beers-from-couchbase-to-mongodb/"/>
    <updated>2015-02-01T15:37:46+01:00</updated>
    <id>http://tgrall.github.io/blog/2015/02/01/moving-my-beers-from-couchbase-to-mongodb</id>
    <content type="html"><![CDATA[<p>Few days ago I have posted a <em>joke</em> on Twitter</p>

<blockquote class="twitter-tweet" lang="en"><p>Moving my Java from Couchbase to MongoDB <a href="http://t.co/Wnn3pXfMGi">pic.twitter.com/Wnn3pXfMGi</a></p>&mdash; Tugdual Grall (@tgrall) <a href="https://twitter.com/tgrall/status/559664540041117696">January 26, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>So I decided to move it from a simple picture to a <em>real</em> project. Let&rsquo;s look at the two phases of this so called project:</p>

<ul>
<li>Moving the data from Couchbase to MongoDB</li>
<li>Updating the application code to use MongoDB</li>
</ul>


<p>Look at this screencast to see it in action:</p>

<p>{% youtube Fpl74Z0HbC0  %}</p>

<!-- more -->


<h2>Moving the data</h2>

<p>I have created a replication server, that uses the Couchbase XDCR protocol to get the document out and insert them into MongoDB. This server use the Couchbase CAPI Server project available <a href="https://github.com/couchbaselabs/couchbase-capi-server">here</a>.</p>

<p>This server will receive all the mutations made in the Couchbase:</p>

<ul>
<li>When a document is inserted or updated the full document is sent</li>
<li>When a document is deleted, only the medata are sent</li>
<li>The <code>replication server</code>, save the data into MongoDB (inserts and/or updates - no delete), and then return the list to Couchbase as part of the XDCR Protocol.</li>
</ul>


<p>One of the challenges is the fact Couchbase does not have the notion of &ldquo;types&rdquo; or &ldquo;collections&rdquo;. You put everything in a <em>bucket</em> and the application code knows how to deal with the data. Not necessary a problem, just a choice of implementation, but make it sometime harder than expected when you want to write tools. So here the logic that I apply in my replication server, to organize the data in multiple collections when it makes sense <em>(and when it is possible)</em>:</p>

<ul>
<li>If the JSON document does not contains a <em>type field</em>, all the documents will be saved in a single collection</li>
<li>If the JSON document contains a <em>type field</em> then a collection will be created for each type and documents will be inserted/updated in these collections</li>
<li>MongoDB does not allow attributes key to have . and $ signs, so it is necessary to change the name with alternative characters. This is done automatically during the copy of the data.</li>
</ul>


<p>All this, and more is configurable in the tool.</p>

<p>As you can see in the screencast this is straightforward.<em>(note that I have only tested very simple use cases and deployment)</em></p>

<p>You can download the tool and the source code here:</p>

<ul>
<li><a href="https://github.com/tgrall/mongodb-cb-replicator">https://github.com/tgrall/mongodb-cb-replicator</a></li>
<li>Download the <a href="http://goo.gl/WkuHBk">MongoCBReplicator.jar</a> file.</li>
</ul>


<h2>Updating the application code</h2>

<p>The next step is to use these data in an application. For this I simply use the Beer Sample Java application available on <a href="https://github.com/couchbaselabs/beersample-java">Couchbase repository</a>.</p>

<p>I just recreated the project and modified few things, to get the application up and running:</p>

<ul>
<li>Change the connection string</li>
<li>Remove the code that generate views</li>
<li>Replace set/get by MongoDB operations</li>
<li>Replace call to the views by simple queries</li>
</ul>


<p>The code of the MongoDBeer application is available here:</p>

<ul>
<li>[<a href="https://github.com/tgrall/mongodbeer">https://github.com/tgrall/mongodbeer</a>]</li>
</ul>


<p>I did not change any business logic, or added features, or even replaced the way navigation and page rendition is made. I just focused on the database access, for example :</p>

<pre><code class="java">
// Couchbase Query
View view = client.getView("beer", "by_name");
    Query query = new Query();
    query.setIncludeDocs(true).setLimit(20);
    ViewResponse result = client.query(view, query);

    ArrayList&lt;HashMap&lt;String, String&gt;&gt; beers =
      new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();
    for(ViewRow row : result) {
      HashMap&lt;String, String&gt; parsedDoc = gson.fromJson(
        (String)row.getDocument(), HashMap.class);

      HashMap&lt;String, String&gt; beer = new HashMap&lt;String, String&gt;();
      beer.put("id", row.getId());
      beer.put("name", parsedDoc.get("name"));
      beer.put("brewery", parsedDoc.get("brewery_id"));
      beers.add(beer);
    }
    request.setAttribute("beers", beers);


// MongoDB Query
DBCursor cursor = db.getCollection("beer").find()
                                                   .sort( BasicDBObjectBuilder.start("name",1).get() )
                                                   .limit(20);
     ArrayList&lt;HashMap&lt;String, String&gt;&gt; beers =
             new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();
     while (cursor.hasNext()) {
         DBObject row = cursor.next();
         HashMap&lt;String, String&gt; beer = new HashMap&lt;String, String&gt;();
         beer.put("id", (String)row.get("_id"));
         beer.put("name", (String)row.get("name"));
         beer.put("brewery", (String)row.get("brewery_id"));
         beers.add(beer);
     }



// Couchbase update
client.set(beerId, 0, gson.toJson(beer));

// MongoDB update
db.getCollection("beer").save(new BasicDBObject(beer));
</code></pre>

<p>I did not attend to optimize the MongoDB code,  but just to replace as few lines of code as possible.</p>

<p>Note: I have not created any index during the process. Obviously if your application have more and more data and you do intense work with it you must analyze your application/queries to see which indexes must be created.</p>

<h2>Adding new features</h2>

<p>Once you have the data into MongoDB you can do a lot more without anything more than MongoDB:</p>

<h4>Full Text Search</h4>

<p>You can create a Text index on various fields in the collection to provide advanced search capabilities to your users.</p>

<pre><code class="json">db.brewery.ensureIndex(
  {
    "name" : "text",
    "description" : "text"
  },
  {
    "weights" :
    {
      "name" : 10,
      "description" : 5
    },
    "name" : "TextIndex"
  }

);
</code></pre>

<p>Then you can query the database using the <code>$text</code> operation, for example all breweries with <em>Belgium</em> and without <em>Ale</em></p>

<pre><code class="json">db.brewery.find( { "$text" : { "$search" : "belgium -ale" }   }  , { "name" : 1  } );
{ "_id" : "daas", "name" : "Daas" }
{ "_id" : "chimay_abbaye_notre_dame_de_scourmont", "name" : "Chimay (Abbaye Notre Dame de Scourmont)" }
{ "_id" : "brasserie_de_cazeau", "name" : "Brasserie de Cazeau" }
{ "_id" : "inbev", "name" : "InBev" }
{ "_id" : "new_belgium_brewing", "name" : "New Belgium Brewing" }
{ "_id" : "palm_breweries", "name" : "Palm Breweries" }
</code></pre>

<h4>Some analytics</h4>

<p>Not sure these queries really make sense, but it is just to show that now you can leverage your documents without the need of any 3rd party tool.</p>

<p>Number of beer by category, from the most common to the less one:</p>

<pre><code class="json">db.beer.aggregate([
  {"$group" : { "_id" : "$category","count" : {"$sum" : 1 } } },
  {"$sort" : { "count" : -1 } },
  {"$project" : {   "category" : "$_id", "count" : 1, "_id" : 0 } }
]);

{ "count" : 1996, "category" : "North American Ale" }
{ "count" : 1468, "category" : null }
{ "count" : 564, "category" : "North American Lager" }
{ "count" : 441, "category" : "German Lager" }
...
...
</code></pre>

<p>Number of beer of a specific ABV by brewery, for example: top 3 breweries with the most beer with an abv greather or equals to a value, let&rsquo;s say 5:</p>

<pre><code class="json">db.beer.aggregate([
... { "$match" : { "abv" : { "$gte" : 5 }  } },
... { "$group" : { "_id" : "$brewery_id", "count" : { "$sum" : 1} }},
... { "$sort" : { "count" : -1 } },
... { "$limit" : 3 }
... ])

{ "_id" : "midnight_sun_brewing_co", "count" : 53 }
{ "_id" : "troegs_brewing", "count" : 33 }
{ "_id" : "rogue_ales", "count" : 31 }
</code></pre>

<h4>Geospatial queries</h4>

<p>The first thing to do with the data is to change the data structure to save the various data into a GeoJSON format, for this we can simply use a script into the MongoDB Shell:</p>

<pre><code class="json">&gt;mongo

use beers

db.brewery.find().forEach(
  function( doc ) {
    var loc = { type : "Point" };
    if (doc.geo &amp;&amp; doc.geo.lat &amp;&amp; doc.geo.lon) {
      loc.coordinates = [ doc.geo.lon , doc.geo.lat  ];
      db.brewery.update( { _id : doc._id } , {$set : { loc : loc } }  );
    }
  }
);

db.brewery.ensureIndex( { "loc" : "2dsphere" } );
</code></pre>

<p>This call take all the breweries and add a new attribute, name <code>loc</code> as a GeoJSON point. I could also chose to remove the old geo information using a &lsquo;$unset&rsquo;, but I did not; let&rsquo;s imagine that some API/applications are using it. This is a good example of flexible schema.</p>

<p>Now I can search for all the brewery that are at less than 30km from the Golden Gate in San Francisco: [-122.478255,37.819929]</p>

<pre><code class="json">db.brewery.find(
  { "loc" :
    { "$near" :
      { "$geometry" :
        {
          "type" : "Point",
          "coordinates" : [-122.478255,37.819929]
        },
        "$maxDistance" : 20000

      }
    }
  }
  , { name : 1 }  
)
</code></pre>

<p>You can also use Geospatial indexes and operators in the aggregation queries used above</p>

<h2>Conclusion</h2>

<p>As as said in the introduction, this week end project started as a joke on Twitter, and finished with a small blog post and Gitub repositories.</p>

<p>My goal here is not to compare the two solutions -I made my choice few months back-  but simply show how you can move from one to the other with almost no effort, not only the data but also the application code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Create a Pub/sub Application With MongoDB ? Introduction]]></title>
    <link href="http://tgrall.github.io/blog/2015/01/12/how-to-create-a-pub-slash-sub-application-with-mongodb-introduction/"/>
    <updated>2015-01-12T09:21:03+01:00</updated>
    <id>http://tgrall.github.io/blog/2015/01/12/how-to-create-a-pub-slash-sub-application-with-mongodb-introduction</id>
    <content type="html"><![CDATA[<p>In this article we will see how to create a pub/sub application (messaging, chat, notification), and this fully based on MongoDB (without any message broker like RabbitMQ, JMS, &hellip; ).</p>

<p>So, what needs to be done to achieve such thing:</p>

<ul>
<li>an application &ldquo;publish&rdquo; a message. In our case, we simply save a document into MongoDB</li>
<li>another application, or thread, subscribe to these events and will received message automatically. In our case this means that the application should automatically receive newly created document out of MongoDB</li>
</ul>


<p>All this is possible with some very cool MongoDB features: <a href="http://docs.mongodb.org/manual/core/capped-collections/">capped collections</a> and <a href="http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/">tailable cursors</a>,</p>

<!-- more -->


<h2>Collections and Tailable Cursors</h2>

<p>As you can see in the documentation, Capped Collections are fixed sized collections, that work in a way similar to circular buffers: once a collection fills its allocated space, it makes room for new documents by overwriting the oldest documents.</p>

<p>MongoDB Capped Collections can be queried using Tailable Cursors, that are similar to the unix <code>tail -f</code> command. Your application continue to retrieve documents as they are inserted into the collection. I also like to call this a &ldquo;continuous query&rdquo;.</p>

<p>Now that we have seen the basics, let&rsquo;s implement it.</p>

<h2>Building a very basic application</h2>

<h4>Create the collection</h4>

<p>The first thing to do is to create a new capped collection:</p>

<p>{% gist f16b1d3b5bcc12a4270a capped-collection %}</p>

<p>For simplicity, I am using the MongoDB Shell to create the <code>messages</code> collection in the <code>chat</code> database.</p>

<p>You can see on line #7 how to create a capped collection, with 2 options:</p>

<ul>
<li><code>capped : true</code> : this one is obvious</li>
<li><code>size : 10000</code> : this is a mandatory option when you create a capped collection. This is the maximum size in bytes. (will be raised to a multiple of 256)</li>
</ul>


<p>Finally, on line #9, I insert a dummy document, this is also mandatory to be able to get the tailable cursor to work.</p>

<h4>Write an application</h4>

<p>Now that we have the collection, let&rsquo;s write some code. First in <em>node.js</em>:</p>

<p>{% gist f16b1d3b5bcc12a4270a app.js %}</p>

<p>From lines #1 to 5 I just connect to my local mongoDB instance.</p>

<p>Then on line #7, I get the <code>messages</code> collection.</p>

<p>And on line #10, I execute a find, using a tailable cursor, using specific options:</p>

<ul>
<li><code>{}</code> : no filter, so all documents will be returned</span></li></li>
<li><code>tailable : true</code> : this one is clear, to say that we want to create a tailable cursor</li>
<li><code>awaitdata : true</code> : to say that we wait for data before returning no data to the client</li>
<li><code>numberOfRetries : -1</code> : The number of times to retry on time out, -1 is infinite, so the application will keep trying</li>
</ul>


<p>Line #11 just force the sort to the natural order.</p>

<p>Then on line #12, the cursor returns the data, and the document is printed in the console each time it is inserted.</p>

<h4>Test the Application</h4>

<p>Start the application</p>

<p><code>node app.js</code></p>

<p>Insert documents in the messages collection, from the shell or any other tool.</p>

<p>You can find below a screencast showing this very basic application working:</p>

<p>{% youtube uSuiYvssKuo %}</p>

<p>The source code of this sample application in this Github repository, take the step-01 branch; clone this branch using:</p>

<p><code>git clone -b step-01 https://github.com/tgrall/mongodb-realtime-pubsub.git</code></p>

<p>I have also created a gist showing the same behavior in <em>Java</em>:</p>

<p>{% gist f16b1d3b5bcc12a4270a MyApp.java %}</p>

<p>Mathieu Ancelin has written it in <em>Scala</em>:</p>

<p>{% gist f16b1d3b5bcc12a4270a App.scala %}</p>

<h3>Add some user interface</h3>

<p>We have the basics of a publish subscribe based application:</p>

<ul>
<li>publish by inserting document into MongoDB</li>
<li>subscribe by reading document using a tailable cursor</li>
</ul>


<p>Let&rsquo;s now push the messages to a user using for example socket.io. For this we need to:</p>

<ul>
<li>add socket.io dependency to our node project</li>
<li>add HTML page to show messages</li>
</ul>


<p>The following gists shows the updated version of the app.js and index.html, let&rsquo;s take a look:</p>

<p>{% gist d8c2acfdc416abcc5d18 app.js %}</p>

<p>The node application has been updated with the following features:</p>

<ul>
<li>lines #4-7: import of http, file system and socket.io</li>
<li>lines #10-21: configure and start the http server. You can see that I have created a simple handler to serve static html file</li>
<li>lines #28-39: I have added support to Web socket using socket.io where I open the tailable cursor, and push/emit the messages on the socket.</li>
</ul>


<p>As you can see, the code that I have added is simple. I do not use any advanced framework, nor manage exceptions, this for simplicity and readability.</p>

<p>Let&rsquo;s now look at the client (html page).</p>

<p>{% gist d8c2acfdc416abcc5d18 index.html %}</p>

<p>Same as the server, it is really simple and does not use any advanced libraries except socket.io client (line #18) and JQuery (line #19), and used:</p>

<ul>
<li>on line #22 to received messages ans print them in the page using JQuery on line #23</li>
</ul>


<p>I have created a screencast of this version of the application:</p>

<p>{% youtube N9fDxuohdy8 %}</p>

<p>You can find the source code in this Github repository, take the step-02 branch; clone this branch using:</div></p>

<p><code>git clone -b step-02 https://github.com/tgrall/mongodb-realtime-pubsub.git</code></p>

<h3>Conclusion</h3>

<p>In this first post, we have:</p>

<ul>
<li>learned about tailable cursor and capped collection</li>
<li>see how it can be used to develop a pub/sub application</li>
<li>expose this into a basic web socket based application</li>
</ul>


<p>In the next article we will continue to develop a bigger application using these features.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Implement Document Versioning With Couchbase]]></title>
    <link href="http://tgrall.github.io/blog/2013/07/18/how-to-implement-document-versioning-with-couchbase/"/>
    <updated>2013-07-18T08:59:50+02:00</updated>
    <id>http://tgrall.github.io/blog/2013/07/18/how-to-implement-document-versioning-with-couchbase</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Developers are often asking me how to &ldquo;version&rdquo; documents with Couchbase 2.0. The short answer is: the clients and server do not expose such feature, but it is quite easy to implement.</p>

<p>In this article I will use a basic approach, and you will be able to extend it depending of your business requirements.</p>

<!-- more -->


<h3>Design</h3>

<p>The first thing to do is to select how to &ldquo;store/organize&rdquo; the versions of your document, and for this you have different designs:</p>

<ul>
<li>copy the versions the document into new documents</li>
<li>copy the versions of the document into a list of embedded documents</li>
<li>store the list of attributes that have been changed into a embedded element (or new documents)</li>
<li>store the &ldquo;delta&rdquo;</li>
<li>…</li>
</ul>


<p>You will have to chose the design based on your application requirements (business logic, size of the dataset, &hellip;).  For this article, let&rsquo;s use one of the most simplistic approach: create new document for each version with the following rules for the keys:</p>

<ol>
<li>The current version is is a simple Key/Document, no change to the key.</li>
<li>The version is a copy of the document, and the version number is added to the key.</li>
</ol>


<p>This looks like:</p>

<pre><code>Current Version   mykey
Version 1         mykey::v1
Version 2         mykey::v2
...               ...
</code></pre>

<p>With this approach, existing applications will always use the current version of the document, since the key is not changed. But this approach creates new documents that will be indexed by existing views.</p>

<p>For example, in the Beer Sample application, the following view is used to list the beer by name:</p>

<pre><code class="js">function (doc, meta) {
  if(doc.type &amp;amp;&amp;amp; doc.type == "beer") {
    emit(doc.name);
  }
}
</code></pre>

<p>It is quite simple to &ldquo;support&rdquo; versioning without impacting the existing code, except the view itself. The new view needs to emit keys,value only for the current version of the document. This is the new view code:</p>

<pre><code>function (doc, meta) {
  if(doc.type &amp;amp;&amp;amp; doc.type == "beer" &amp;amp;&amp;amp; (meta.id).indexOf("::v") == -1   ) {
    emit(doc.name);
  }
}
</code></pre>

<p>With this change the existing applications that are using this view will continue to work with the same behavior.</p>

<h3>Implementing the versioning</h3>

<p>Based on this design, when the application needs to version the document, the following logic should happen:</p>

<ol>
<li>Get the current version of the document</li>
<li>Increment the version number (for example using another key that maintains the version number for each document)</li>
<li>Create the version with the new key  &ldquo;mykey::v1&rdquo;</li>
<li>Save the document current version</li>
</ol>


<p>Let&rsquo;s look at the code in Java</p>

<pre><code class="java">Object obj = client.get(key);
if (obj != null) {
  // get the next version, create or use the key: mykey_version
  long version = client.incr(key + "_version", 1, 1);
  String keyForVersion = key + "::v" + version; // mykey::v1
  try {
    client.set(keyForVersion, obj).get();
    } catch (Exception e) {
      logger.severe("Cannot save version "+ version + " for key "+ key +" - Error:"+ e.getMessage() );
    }
  }
  client.set(key, value);
</code></pre>

<p>Quite simple isn&rsquo;t?</p>

<p>The application can access the document using the key, but also get one version or the list of all versions, this is one of the reasons why it is interesting to create a key (<span style="font-family: Courier New, Courier, monospace;">mykey_version</span>), and use it also to delete documents and related versions.</p>

<p>Based on the previous comment, the delete operation looks like:</p>

<pre><code class="java">Object obj = client.get(key);
// need to delete all the version first
Object vObject = this.get(key + "_version");
if (vObject != null) {
  long biggerVersion = Long.parseLong((String) vObject);
  try {
    // delete all the versions
    for (int i = 1; i &lt;= biggerVersion; i++) {
      String versionKey = key + "::v" + i;
      client.delete(versionKey).get();
    }
    // delete the counter
    client.delete(key + "_version").get();
  } catch (InterruptedException e) {
    e.printStackTrace();
  } catch (ExecutionException e) {
    e.printStackTrace();
  }
}
client.delete(key);
</code></pre>

<h4>Use versioning</h4>

<p>As an example, I have created a small library available on GitHub <a href="https://github.com/tgrall/couchbase-how-to-versioning">https://github.com/tgrall/couchbase-how-to-versioning</a>, this library extends the Couchbase Client and overrides some of the operations : set, replace and delete. (the basic one: no TLL, no durability) As I said before this is just an example.</p>

<p><em>Build and Install</em></p>

<pre><code>git clone https://github.com/tgrall/couchbase-how-to-versioning.git
cd how-to-versioning
mvn clean install
</code></pre>

<p>Then add this library to your project in addition to Couchbase Java Client, for example in your pom.xml</p>

<pre><code class="xml">...
&lt;dependency&gt;
  &lt;groupid&gt;com.couchbase.howtos&lt;/groupid&gt;
  &lt;artifactid&gt;couchbase-how-to-versioning&lt;/artifactid&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupid&gt;couchbase&lt;/groupid&gt;
  &lt;artifactid&gt;couchbase-client&lt;/artifactid&gt;
  &lt;version&gt;1.1.8&lt;/version&gt;
&lt;/dependency&gt;

...
</code></pre>

<p><em>Code your application</em></p>

<p>Create a document and version it:</p>

<pre><code class="java">List&lt;uri&gt; uris = new LinkedList&lt;uri&gt;();
uris.add(URI.create("http://127.0.0.1:8091/pools"));
CouchbaseClientWithVersioning client = null
try {
  client = new CouchbaseClientWithVersioning(uris, "default", "");
  String key = "key-001";
  client.set(key, "This is the original version");
  System.out.printf("Original '%s' .\n", client.get(key));
  client.set(key, "This is a new version", true); // create a new version
  System.out.printf("Current Version '%s' .\n", client.get(key));
  System.out.printf("Version 1 '%s' .\n", client.get(key, 1));
  client.set(key, "This is another version", true); // create a new version
  System.out.printf("All versions %s .\n", client.getAllVersions(key));
  client.deleteVersion(key, 1); // create a new version
  System.out.printf("All versions %s (after delete 1 version).\n", client.getAllVersions(key));
  client.delete(key); // create a new version
  System.out.printf("All versions %s (after delete the main key).\n", client.getAllVersions(key));
} catch (Exception e) {
  e.printStackTrace();
}
if (client !=null) {
  client.shutdown();
}
</code></pre>

<p>Quick explanation:</p>

<ul>
<li>Line 5: instead of using the <code>CouchbaseClient</code>, the application uses the extended <code>CouchbaseClientWithVersioning</code> class.</li>
<li>Line 7: create a new entry</li>
<li>Line 9: create a new version, the boolean value to &ldquo;true&rdquo; force the versioning of the document</li>
<li>The application use other methods such as get a specific version (line 11), get all versions (line 13), delete a specific version (line 14), and finally delete the key and all versions (line 16).</li>
</ul>


<p>So using this approach the developer controls explicitly when to create a version, since he has to add the boolean parameter in the set operation. In this small sample library it is also possible to do auto versioning, in this case all set and replace calls will create a version, to achieve that the developer just needs to call the setAutoVersioning(true) method. Something like:</p>

<pre><code class="java">client = new CouchbaseClientWithVersioning(uris, "default", "");
client.setAutomaticVersionning(true);
</code></pre>

<p>With this approach you can provide versioning to your application with minimal code change. You can test it in the Beer Sample application, just do not forget to change the views as documenter above to only return <em>current</em> version of the documents.</p>

<h3>Conclusion</h3>

<p>As you can see doing versioning in Couchbase is not that complicated, but it is something that must be done by your application based on its requirements and constraints. You have many different solution and none of these options is perfect for all use cases.</p>

<p>In this specific sample code, I am working with a simple design where I create a copy of the documents for each version. With this approach also, it is interesting to mention that you can version &ldquo;anything&rdquo;, not only JSON document but also any values.  As I said before, this is one possible approach, and like any design, it has some impact on the application or database, in this case most the database:</p>

<ul>
<li>Increase the number of keys and documents</li>
<li>Double - or more- the number of operations, for example when updating a document, the application needs to get the current value, create a version, save the current version.</li>
<li>Consistency management when adding new version and incrementing the version number (need to deal with errors when creating a new version, deleting the versions and counter&hellip;.)</li>
</ul>


<p>Many features could be added to this easily, for example:</p>

<ul>
<li>Limit to a specific number of version,</li>
<li>Enable the versioning only of replace() operation</li>
<li>Add specific attribute about versions in JSON document (for example date of the version)</li>
<li>&hellip;.</li>
</ul>


<p>If you are using versioning in your Couchbase application feel free to comment or write a small article that describes the way your are doing it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Couchbase 101: Create Views (MapReduce) From Your Java Application]]></title>
    <link href="http://tgrall.github.io/blog/2012/12/30/couchbase-101-create-views-mapreduce-from-your-java-application/"/>
    <updated>2012-12-30T10:42:24+01:00</updated>
    <id>http://tgrall.github.io/blog/2012/12/30/couchbase-101-create-views-mapreduce-from-your-java-application</id>
    <content type="html"><![CDATA[<p>When you are developing a new applications with Couchbase 2.0, you sometimes need to create view dynamically from your code. For example you may need this when you are installing your application, writing some test, or you can also use that when you are building frameworks, and wants to dynamically create views to query data. This post shows how to do it.</p>

<h3>Prerequisites</h3>

<ul>
<li><a href="http://www.couchbase.com/download">Couchbase Server 2.0</a></li>
<li><a href="http://www.couchbase.com/develop/java/current">Couchbase Jave Client Library 1.1.x</a></li>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-sampledata-beer.html">Beer Sample dataset</a></li>
</ul>


<p>If you are using Maven you can use the following information in your <code>pom.xml</code> to add the Java Client library:</p>

<pre><code class="xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;couchbase&lt;/id&gt;
    &lt;name&gt;Couchbase Maven Repository&lt;/name&gt;
    &lt;layout&gt;default&lt;/layout&gt;
    &lt;url&gt;http://files.couchbase.com/maven2/&lt;/url&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/snapshots&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupid&gt;couchbase&lt;/groupid&gt;
    &lt;artifactid&gt;couchbase-client&lt;/artifactid&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
    &lt;type&gt;jar&lt;/type&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>See online at <a href="https://gist.github.com/4337172">https://gist.github.com/4337172</a></p>

<h3>Create and Manage Views From Java</h3>

<p>The full Maven project is available on <a href="https://github.com/tgrall/couchbase-java-101/tree/master/java-document-design/">Github</a>.</p>

<h4>Connect to Couchbase Cluster</h4>

<p>The first thing to do when you want to create a view from Java is obviously to connect to the cluster.</p>

<pre><code class="java">import com.couchbase.client.CouchbaseClient;
...

List&lt;uri&gt; uris = new LinkedList&lt;uri&gt;();
uris.add(URI.create("http://127.0.0.1:8091/pools"));
CouchbaseClient client = null;
try {
  client = new CouchbaseClient(uris, "beer-sample", "");

  // put your code here

  client.shutdown();

  } catch (Exception e) {
    System.err.println("Error connecting to Couchbase: " + e.getMessage());
    System.exit(0);
  }
...
</code></pre>

<ol>
<li>Create a list of URIs to different nodes of the cluster - lines 5-6. (In this example I am working on a single node)</li>
<li>Connect to the bucket, in our case <code>beer-sample</code> -line 9. You can include the password if the bucket is protected ( this is not the case here so I am sending an empty string)</li>
</ol>


<p>If you are looking for more information about Couchbase and Java, you can read this article from DZone : <a href="http://architects.dzone.com/articles/hello-world-couchbase-and-java">Hello World with Couchbase and Java</a>.</p>

<p>Let&rsquo;s now talk about Couchbase views. You use views/map-reduce functions to index and query data from Couchbase Server based on the content of the JSON document you store inside Couchbase. For more information about views you can look at the <a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-views-basics.html">&ldquo;view basics&rdquo; chapter</a> of the Couchbase Server Manual.</p>

<h4>Create Views from Java</h4>

<p>Creating a view from Java is really easy : the Java Client Library contains all the classes and methods to do it. As a concrete use case we will use the Application that is described in the <a href="http://www.couchbase.com/docs/couchbase-sdk-java-1.1/tutorial.html">Couchbase Java Tutorial</a>.</p>

<p>When you follow this tutorial, you need to manually create some views, as you can see <a href="http://www.couchbase.com/docs/couchbase-sdk-java-1.1/preps-views.html">here</a>. In this example, we will create our map function and directly in our Java code and then store it to Couchbase Server. The tutorial asks you to create the following artifacts:</p>

<ul>
<li>a view named &ldquo;by_name&rdquo;</li>
<li>in the design document named <code>"dev_beer"</code> (development mode)</li>
<li>and the map function which looks like the following :</li>
</ul>


<pre><code class="js">function (doc, meta) {
  if(doc.type &amp;&amp; doc.type == "beer") {
    emit(doc.name, null);
  }
}
</code></pre>

<p>The following code allows you to do it from Java:</p>

<pre><code class="java">import com.couchbase.client.protocol.views.DesignDocument;
import com.couchbase.client.protocol.views.ViewDesign;
...
DesignDocument designDoc = new DesignDocument("dev_beer");

String viewName = "by_name";
String mapFunction =
"function (doc, meta) {\n" +
"  if(doc.type &amp;&amp; doc.type == \"beer\") {\n" +
"    emit(doc.name);\n" +
"  }\n" +
"}";

ViewDesign viewDesign = new ViewDesign(viewName,mapFunction);
designDoc.getViews().add(viewDesign);
client.createDesignDoc( designDoc );
...
</code></pre>

<ul>
<li>Create a design document using the <code>com.couchbase.client.protocol.views.DesignDocument</code> class - line 4.</li>
<li>Create a view using <code>com.couchbase.client.protocol.views.ViewDesign</code> class with a name and the map function - line 14.</li>
<li>You can add this view to a design document - line 15</li>
<li>Finally save the document into the cluster using the <code>CouchbaseClient.createDesignDoc</code> method.</li>
</ul>


<p>If you need to use a reduce function (built-in or custom) you just need to pass to the ViewDesign constructor as 3rd parameter.</p>

<p>When developing view, from Java or from any other tool/language be sure you understand what are the best practices, and the life cycle of the index. This is why I am inviting you to take a look to the following chapters in the Couchbase documentation:</p>

<ul>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-views-writing-bestpractice.html">View Writing Best Practice</a> : for example in the map function, I do not emit any value. I only emit a key (the beer name).</li>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-views-datastore.html">Views and Stored Data</a></li>
<li><a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-views-types.html">Development and Production Views</a> : in the view above, I have created the view in the development environment (<span style="font-family: Courier New, Courier, monospace;">dev_</span> prefix) allowing me to test and use it on a subset of the data (cluster/index)</li>
</ul>


<h4>Using the view</h4>

<p>First of all, the view that you just created is in &ldquo;development mode&rdquo;, and by default the Java client SDK will only access the view when it is in &ldquo;production mode&rdquo;. This means that when you are calling a view from your application it will search it into the production environment. So before connecting to Couchbase cluster you need to setup the <code>viewmode</code> to development.</p>

<p>This is done using the <code>viewmode</code> environment variable from the Java SDK, that could be set using the following methods:</p>

<ul>
<li>In your code, add this line <strong>before</strong> the client connects to the cluster : <code>System.setProperty("viewmode", "development");</code></li>
<li>At the command line <code>-Dviewmode=development</code></li>
<li>In a properties file <code>viewmode=development</code></li>
</ul>


<p>Once it is done you can call the view using the following code:</p>

<pre><code class="java">import import com.couchbase.client.protocol.views.*;

...
System.setProperty("viewmode", "development"); // before the connection to Couchbase
...
View view = client.getView("beer", "by_name");
Query query = new Query();
query.setIncludeDocs(true).setLimit(20);
query.setStale( Stale.FALSE );
ViewResponse result = client.query(view, query);
for(ViewRow row : result) {
  row.getDocument(); // deal with the document/data
}
...
</code></pre>

<p>This code queries the view you just created. This means Couchbase Server will generate an index based on your map function, will query the server for results. In this case, we specifically want to set a limit of 20 results and also get the most current results by setting Stale.FALSE.</p>

<ul>
<li>Set the <code>viewmode</code> to <code>development</code> - line 4</li>
<li>Get the view using the <code>CouchbaseClient.getView()</code> method -line 6-. As you can see I just use the name beer for the design document (and not dev_beer, Couchbase will know where to search since I am in development mode)</li>
<li>Create a query and set a limit (20) and ask the SDK to return the document itself
<code>setIncludeDocs(true)</code> -line 8- The document will be returned from Couchbase server in the most efficient way</li>
<li>Ask the system to update the index before returning the result using query.setStale( Stale.FALSE <code>);</code>-line 9-. Once again be careful when you use setStale method. Just to be sure here is the documentation about it : <a href="http://www.couchbase.com/docs/couchbase-manual-2.0/couchbase-views-writing-stale.html">Index Updates and the stale Parameter</a></li>
<li>Execute the query - line 10</li>
<li>And use the result - lines 11-13</li>
</ul>


<h3>Conclusion</h3>

<p>In this article, you have learned:</p>

<ul>
<li>How to create Couchbase views from Java</li>
<li>Call this view from Java</li>
<li>Configure development/production mode views from Couchbase Java Client Library</li>
</ul>


<p>This example is limited to the creation of a view, you can take a look to the other methods related to design documents and views if you want to manage your design documents : <code>getDesignDocument()</code>, <code>deleteDesignDocument()</code>, &hellip;</p>
]]></content>
  </entry>
  
</feed>
